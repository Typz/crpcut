<doc title="crpcut-0.7.3 - The Compartmented Robust Posix C++ Unit Tester">
<abstract>
crpcut (pronounced &quot;crap cut&quot;) is the
Compartmented Robust Posix C++ Unit Tester
<p/>
With crpcut it is easy to write tests that other unit-test frame works cannot
manage.<p/>
</abstract>
<chapter title="Introductory example">
<p/>
An example testing parts of std::string:<p/>
<code>
  #include &lt;crpcut.hpp&gt;
  #include &lt;string&gt;

  struct apastr // fixture for mosts tests
  {
    apastr() : s("apa") {}
    std::string s;
  };

  TESTSUITE(basics)
  {
    TEST(default_constr_and_destr)
    {
      std::string s;
      ASSERT_TRUE(s.empty());
      ASSERT_EQ(s.length(), 0);
    }
    TEST(constr_from_char_array, apastr,
                                 DEPENDS_ON(default_constr_and_destr))
    {
      ASSERT_EQ(s.length(), 3UL);
    }
    TEST(at, apastr,
             DEPENDS_ON(default_constr_and_destr))
    {
      ASSERT_EQ(s.at(1), 'p');
    }
  }

  TESTSUITE(errors, DEPENDS_ON(ALL_TESTS(basics)))
  {
    TEST(at_out_of_range, apastr,
                          EXPECT_EXCEPTION(std::out_of_range))
    {
      s.at(4);
    }
    TEST(index_oper_out_of_range, apastr,
                                  EXPECT_SIGNAL_DEATH(SIGABRT),
                                  NO_CORE_FILE)
    {
      s[4];
    }
  }

  int main(int argc, char *argv[])
  {
    return crpcut::test_case_factory::run_test(argc, argv);
  }
</code>
Similar tests benefits from being grouped into test-suites. Test-suites
can depend on other test-suites, meaning that the contained tests will only
run if all tests it depends on have completed successfully. Results
can be validated using a number of <id>ASSERT</id> macros. Tests can use
fixtures to express common contents. Tests can be expected to exit by
exception, or die. Expectations that are not met are errors. Messages on
<id>stderr</id> and <id>stdout</id> are collected, and included in the result log.
</chapter>

<chapter title="Why crpcut">
Most importantly, it must be easy to write tests. With crpcut, you focus
on your test structure and test logic, not on the limits imposed by
your test environment.
<p/>
With crpcut, every test case runs in its own process and its own working
directory. If a test case fails, the process terminates immediately, before
it does further harm. This means that every test case starts from a clean
slate, unaffected by other tests. This is the compartmentalization.
<p/>
It also means that the test suite continues, even if a test crashes.
You can set deadlines for test cases, and if the allowed time is seriously
overdrawn, the test case process is killed. These two make up the robustness
part.
<p/>
You can define dependencies between test cases and between test suites, so that
if a fundamental tests fails, the tests that are based on the fundamental
functionality will not even be run.
<p/>
The crpcut main process does not have any dynamic memory allocated at the
time a test case process is started, so you can run crpcut using a memory
test tool, such as <link url="http://www.valgrind.org">valgrind</link>,
 and if there is memory allocated when the test
case process terminates, you can be assured that you have found a memory leak
in your test.
<p/>
If you have a multi-core CPU, it may be beneficial to run several test cases
in parallel. crpcut allows that.
<p/>
If there are files left in the test process' working directory after the test
case process has terminated, the test case is considered failed. The working
directory is left untouched by crpcut, for you to examine.
</chapter>

<chapter title="Competition">
You may want to check out the competition and decide which system is best for
you.
<list>
<li><link url="http://code.google.com/p/googletest/">googletest</link></li>
<li><link url="http://cppunit.sourceforge.net">CppUnit</link></li>
<li><link url="http://unittest-cpp.sourceforge.net">UnitTest++</link></li>
</list>
</chapter>

<chapter title="crpcut links">
The current version of crpcut is 0.7.3
<p/>
<li>Latest version of <link url="http://crpcut.sourceforge.net">this document</link></li>
<li>Sourceforge <link url="http://www.sourceforge.net/projects/crpcut">project page</link></li>
<li>Sourceforge <link url="https://sourceforge.net:443/project/showfiles.php?group_id=251473">download page</link></li>
<li>GIT repo at <id>git://crpcut.git.sourceforge.net/gitroot/crpcut/crpcut</id></li>
<li>Support <link url="http://lists.sourceforge.net/mailman/listinfo/crpcut-users">mailing list</link></li>
<li><link url="http://sourceforge.net/tracker/?group_id=251473">bug-tracker</link></li>
</chapter>
<chapter title="License">
<code>
/*
 * Copyright 2009 Bjorn Fahller &lt;bjorn@fahller.se&gt;
 * All rights reserved

 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

</code>
</chapter>

<chapter title="Requirements">
crpcut relies on a few Posix functions, and three extensions to C++ (as defined
by the 1998 standard and the 2003 corrigendum.)
<p/>
The C++ extensions are:
<definitions notion="extension" meaning="where defined">
  <def notion="variadic macros">C99/c++0x</def>
  <def notion="decltype">c++0x (typeof, which in current gcc is similar enough,
                         is tried if decltype isn&apos;t availble)</def>
  <def notion="_Exit()">C99/c++0x</def>
</definitions>
All will become standardized for C++ soon, and are since some time supported
by gcc. The lowest version tested with is 4.1.2.
<p/>
The required Posix functions are:
<definitions notion="Standard" meaning="Requirement">
  <def notion="POSIX.1"><code>   EEXIST
   EINTR</code></def>
  <def notion="POSIX.1-2001"><code>   alloca()
   chdir()
** clock_gettime(CLOCK_MONOTONIC)
** clock_gettime(CLOCK_PROCESS_CPUTIME_ID)
   close()
   closedir()
   dup2()
++ epoll_create()
++ epoll_ctl()
++ epoll_wait()
   fork()
   getcwd()
   gethostname()
** getitimer(ITIMER_REAL)
** getitimer(ITIMER_VIRTUAL)
   kill()
   mkdir()
   open()
   opendir()
   pipe()
   read()
   readdir_r()
-- regcomp()
-- regexec()
-- regerror()
-- regfree()
   rmdir()
++ select()
** setitimer(ITIMER_REAL)
** setitimer(ITIMER_VIRTUAL)
   setrlimit(RLIMIT_CORE)
   setrlimit(RLIMIT_CPU)
   waitid()
   write()</code></def>
  <def notion="POSIX.1-2008"><code>   mkdtemp()</code></def>
</definitions>
<definitions>
<def notion="**"><id>clock_gettime()</id> will be used if available.
<id>*itimer()</id> will be used as a fallback.</def>
<def notion="++"><id>epoll_*</id> will be used if available. <id>select()</id>
                 will be used as a fallback.</def>
<def notion="--"><id>reg*</id> will be used only when matching strings with
                 regular expressions.</def>
<def notion="">On OS-X <id>mach_absolute_time()</id> and
<id>mach_timebase_info()</id> will be used for realtime measurements.</def>
</definitions>
This should work for most Linux systems. It is also likely to work for
 <link url="http://www.apple.com/macosx/">OS-X</link>, but it has not yet
been verified.
</chapter>
<chapter title="Build and Install">
  crpcut uses <link url="http://www.cmake.org">CMake</link> to manage builds and
  installs.<p/>
First obtain the crpcut sources, either a release from the
sourceforge
<link url="https://sourceforge.net:443/project/showfiles.php?group_id=251473">download</link>
page, or from the git repository
<id>git://crpcut.git.sourceforge.net/gitroot/crpcut</id>
<p/>
In a build directory (can be the same as the source directory)
<code>
  &gt; cmake path
</code>
Where <id>path</id> is the path to the crpcut source directory.
<p/>
Should you want to use a different install directory than the
<link url="http://www.cmake.org">CMake</link> default, type instead
<code>
  &gt; cmake path -DCMAKE_INSTALL_PREFIX=&lt;desired_install_directory&gt;
</code>
<p/>
If you want to enable support for
<link url="http://code.google.com/p/googlemock">google-mock</link> add also
<code>
  -DWITH_GOOGLE_MOCK=yes
</code>
to the <link url="http://www.cmake.org">cmake</link> line. If
<link url="http://code.google.com/p/googlemock">google-mock</link> is not
installed in a directory that is reachable by you C++ compiler and
linker, without additional flags, provide
<link url="http://www.cmake.org">CMake</link> with the directory of
<link url="http://code.google.com/p/googlemock">google-mock</link> using:
<code>
  -DGOOGLE_MOCK_DIR=path
</code>
where path is the exact same as used in the <id>--prefix=path</id> option for
<id>configure</id> in
<link url="http://code.google.com/p/googlemock">google-mock</link>.
Note that if you upgrade to a new version of
<link url="http://code.google.com/p/googlemock">google-mock</link>,
you must reinstall crpcut.
<p/>
Once <link url="http://www.cmake.org">CMake</link> has completed, build crpcut
by typing:
<code>
  &gt; make
</code>
<p/>
Once built, you may want to check that it works correctly. Do that by
running first builting the example code as a test program:
<code>
  &gt; make testprog
</code>
Then run the selftest itself:
<code>
  &gt; make selftest
</code>
It takes about 30 seconds to run through all tests. It verifies that the test
cases under <id>test-src</id> completes with the expected result for a large set
of command-line switches.
<p/>
You can now install crpcut by typing:
<code>
  &gt; make install
</code>
The file <id>install_manifest.txt</id> is created and includes the full path
of all installed files.
</chapter>
<chapter title="Writing tests">
Test cases are defined using the <id>TEST()</id> macro as:<p/>
<code>
  TEST(name_of_testcase (,(fixture|modifier))*)
  {
    ... code
  }
</code>
Both <link section="Fixtures">fixtures</link> and
<link section="Modifiers">modifiers</link>
are explained below.
<p/>
If several tests are related, they can be grouped into a test suite using the
<id>TESTSUITE()</id> macro. The macro is used to name a testsuite, and if
desired also use the <id>DEPENDS_ON</id>
<link section="Modifiers">modifier</link> to define dependencies for all tests
in a testsuite. For a large range of tests, it may be a good idea
to nest test suites. A nested testsuite inherits all dependencies of its
enclosing testsuite. Test cases can be written in several files and linked to
one main program. If several files define the same test-suite name, the tests
will be joined it the same suite. Beware of dependencies with testsuites that
span several files; the dependencies are file-local. The <id>crpcut_</id> name
prefix is reserved for crpcut.
<p/>
In tests, assert correctness using the assertion macros.
<p/>
The unary assertions are:
<definitions notion="assert" meaning="condition">
  <def notion="ASSERT_TRUE(expr)">Fails iff <id>expr</id> evaluates to
                                 <id>false</id></def>
  <def notion="ASSERT_FALSE(expr)">Fails iff <id>expr</id> evaluates to
                                   <id>true</id></def>
  <def notion="ASSERT_NO_THROW(expr)">Fails iff <id>expr</id> throws
                                      anything</def>
</definitions>
<p/>
The binary assertions are:
<definitions notion="assert" meaning="condition">
  <def notion="ASSERT_EQ(a, b)">Fails iff the expression <id>(a == b)</id>
                                evaluates to <id>false</id></def>
  <def notion="ASSERT_NE(a, b)">Fails iff the expression <id>(a != b)</id>
                                evaluates to <id>false</id></def>
  <def notion="ASSERT_GT(a, b)">Fails iff the expression <id>(a &gt; b)</id>
                                evaluates to <id>false</id></def>
  <def notion="ASSERT_GE(a, b)">Fails iff the expression <id>(a &gt;= b)</id>
                                evaluates to <id>false</id></def>
  <def notion="ASSERT_LT(a, b)">Fails iff the expression <id>(a &lt; b)</id>
                                evaluates to <id>false</id></def>
  <def notion="ASSERT_LE(a, b)">Fails iff the expression <id>(a &lt;= b)</id>
                                evaluates to <id>false</id></def>
  <def notion="ASSERT_THROW(expr,&#xA0;exc_type)">Fails iff the expression
                                                  <id>expr</id> does not throw
                                                  an exception of type
                                                  <id>exc_type</id>. Use
                                                  <id>...</id> for
                                                  <id>exc_type</id> if any
                                                  exception is good.</def>
</definitions>
<p/>
There is also an N-ary assert macro:
<definitions notion="assert" meaning="condition">
  <def notion="ASSERT_PRED(predicate,&#xA0;...)">Fails iff the expression
                                            <id>predicate(...)</id> evaluates
                                            to false. <id>predicate</id> may
                                            be anything that can act as a
                                            function accepting the rest of
                                            the parameters, and returns a value
                                            comparable to false.</def>
</definitions>
If an assertion fails, the value of the parameters is included in the failure
log (as output streamed, if possible, or as hex-dump otherwise.) All assert
macros evaluates each parameter value exactly once, so providing parameters with
side effects is not a problem. The order of evaluation of the parameters is
undefined, however.
<p/>
<id>ASSERT_PRED</id> has the advantage that it gives you all parameter values.
For example, the two tests below are logically equal:
<code>
  const char *p = afunc();
  ASSERT_TRUE(std::equal_to&lt;std::string&gt;()("expected", p));
</code>
and
<code>
  const char *p = afunc();
  ASSERT_PRED(std::equal_to&lt;std::string&gt;(), "expected", p);
</code>
However, of the two above, the latter will give much better violation
information, should the test fail. Compare:
<code>
  ASSERT_TRUE(std::equal_to&lt;std::string&gt;()("expected", p))
    where std::equal_to&lt;std::string&gt;()("expected", p) = false
</code>
and
<code>
  ASSERT_PRED(std::equal_to&lt;std::string&gt;()("expected", p))
    param1 = expected
    param2 = otherval
</code>
If you define your own predicates (see the <link section="Predicates"/>
section below) you can define an output stream operator for it, to make it
express the nature of the test even better.
<p/>
In addition to the assertions, two output streamers are available. Both
are used as normal <id>std::ostream</id> objects.
<definitions notion="streamer" meaning="action">
<def notion="FAIL">Immediately terminate the test case as a failure with the
                   streamed message.</def>
<def notion="INFO">Add the streamed message to the test-case log, but do
                   not fail it.</def>
</definitions>
Each <id>FAIL</id> or <id>INFO</id> output statement is a complete log
message. There is no need to add line-breaks or other separators.
<p/>
An example:
<code>
  TEST(fail_immediately)
  {
    int n = random();
    INFO &lt;&lt; "random value is " &lt;&lt; n;
    FAIL &lt;&lt; "Goodbye cruel world";
  }
</code>
<section title="Fixtures">
If several test cases share the same test setup, test fixtures can be written.
A fixture is just a <id>class</id> or <id>struct</id>, with the desired
information. The default constructor is expected to fill in the desired
information, and the destructor to clean up afterwards. Several fixtures can
be combined. The fixtures are inherited by the test case.
<p/>
Small example:
<code>
  TESTSUITE(string_length)
  {
    class fixture1
    {
    protected:
      fixture1() : i(3) {}
      int i;
    };
    struct fixture2
    {
      std::string msg;
      fixture2() : msg("cat");
    };

    TEST(check_length, fixture1, fixture2)
    {
      ASSERT_EQ(msg.length(), i);
    }

    TEST(check_c_length, fixture1, fixture2)
    {
      ASSERT_EQ(std::strlen(msg.c_str()), i);
    }
  }
</code>
</section>
<section title="Modifiers">
In addition to using fixtures and asserts, the expected behaviour of
test cases can be altered using modifiers. Modifiers are listed together with
the fixtures.
<p/>
The defined test case modifiers are:
<definitions>
<def notion="NO_CORE_FILE">Make sure the test doesn't produce a core
                           file, no matter how it crashes. Useful when
                           testing that an <id>assert()</id> works as expected.
                           </def>
<def notion="EXPECT_EXIT(code)">For the test to succeed, it must exit with the
                                supplied exit code. If any exit is OK, use
                                <id>ANY_CODE</id> for <id>code</id>.</def>
<def notion="EXPECT_SIGNAL_DEATH(code)">For the test to succeed, it must
                                        terminate on the supplied signal number.
                                        If any signal number is OK, use
                                        <id>ANY_CODE</id> for <id>code</id>.
                                        </def>
<def notion="EXPECT_EXCEPTION(type)">For the test to succeed, it must exit by
                                     throwing an instance of the provided type.
                                     If any exception is good, use
                                     <id>...</id> for
                                     <id>type</id>.</def>
<def notion="DEADLINE_CPU_MS(duration_ms)">For the test to succeed it must run
                                           to completion before consuming
                                           <id>duration_ms</id> milliseconds
                                           CPU-time. If the time consumed is
                                           vastly more, the test process will
                                           be killed (uses <id>setrlimit()</id>
                                           with <id>RLIMIT_CPU</id>, and
                                           <id>clock_gettime()</id> with
                                           <id>CLOCK_PROCESS_CPUTIME_ID</id>.)
                                           </def>
<def notion="DEADLINE_REALTIME_MS(duration_ms)">For the test to succeed it
                                                must run to completion before
                                                consuming <id>duration_ms</id>
                                                milliseconds on the
                                                rate-monotonic clock. If the
                                                time consumed is vastly more,
                                                the crpcut engine will kill it
                                                using <id>kill()</id> with
                                                signal <id>SIGKILL</id>. Time
                                                is measured using
                                                <id>clock_gettime()</id> with
                                                <id>CLOCK_MONOTONIC</id>.</def>
<def notion="DEPENDS_ON(...)">... is a list of test cases, or
                              <id>ALL_TESTS(ns)</id>. Before the test can
                              run, all tests in the list, or all tests in
                              <id>TESTSUITE(ns)</id> must have finished
                              successfully.</def>
</definitions>
</section>
<section title="Disbaled tests">
If, for whatever reason, you have tests that you currently don&apos;t want to
run, but you intend for them to be included later, define them using
<id>DISABLED_TEST()</id> instead of <id>TEST()</id>. Test cases defined with
<id>DISABLED_TEST()</id> are compiled, preventing code-rot, but will never be
a candidate for running. It is not possible to state dependency on a disabled
test.
</section>
</chapter>

<chapter title="Comparing strings">
crpcut currently provides two ways of comparing strings:
<section title="collation">
Collation is comparing strings sort order in a locale. It is possible to mix
both <id>std::string</id> and C strings in collations. It is also possible to
collate <id>wchar_t</id> strings, providing the locale supports it.
<p/>
The basic syntax is:
<code>
  ASSERT_TRUE(crpcut::collate("aaa") op "aaaa")
</code>
where op is one of <id>&lt;</id>, <id>&lt;=</id>, <id>==</id>, <id>!=</id>,
<id>&gt;</id> and <id>&gt;=</id>.
<p/>
Note that <id>==</id> and <id>!=</id> are some of a misnomer. Collation is
about sort order in a locale, so <id>==</id> means the strings are considered
unordered compared to one another, but that doesn't necessarily mean that
they are equal. In some locales, for example, an umlaut is a decoration
(in terms of collation) whereas in other locales the exact same umlaut
makes a letter with a different place in the alphabet.
<p/>
To select which locale to work in, add the locale as the second parameter.
<code>
  ASSERT_TRUE(crpcut::collate("aaa", std::locale("sv_SE")) op s);
</code>
If the locale cannot be constructed, the assertion fails.
<p/>
Example:
<code>
  TEST(de_sv_collation)
  {
    static const char s1[] = "&#246;z";
    static const char s2[] = "z&#246;";
    ASSERT_TRUE(crpcut::collate(s1, std::locale("de_DE")) &lt; s2);
    ASSERT_TRUE(crpcut::collate(s1, std::locale("sv_SE")) &gt; s2);
  }
</code>
You can also convert the strings to uppercase or lowercase before testing the
collation order. This is done using the templated variant of <id>collate</id>.

<definitions notion="template" meaning="meaning">
<def notion="crpcut::collate&lt;crpcut::uppercase&gt;()">
            translate reference string and compared string to upper case, in the
            locale, before comparing collation order.</def>
<def notion="crpcut::collate&lt;crpcut::lowercase&gt;()">
            translate reference string and compared string to lower case,
            in the locale, before comparing collation order.</def>
<def notion="crpcut::collate&lt;crpcut::verbatim&gt;()">
            synonymous with the non-templated version</def>

</definitions>
</section>
<section title="regular expression">
Strings can be matched against regular expressions using <id>ASSERT_PRED</id>
with the <id>match</id> function template instantiated using <id>regex</id>:
<code>
  ASSERT_PRED(crpcut::match&lt;crpcut::regex&gt;(pattern, flags...), string);
</code>
The pattern and the string can be either of <id>std::string</id> or C string.
<p/>
There are three flags available:
<definitions notion="flag" meaning="meaning">
<def notion="crpcut::regex::i">Ignore case when matching. Equal to
                               <id>REG_ICASE</id> in <id>regcomp()</id>. Note
                               that this does not take any locale into
                               consideration.</def>
<def notion="crpcut::regex::e">Use extended regular expressions. Equal to
                               <id>REG_EXTENDED</id> in <id>regcomp()</id></def>
<def notion="crpcut::regex::m">Pattern is multi line. Equal to
                               <id>REG_NEWLINE</id> in <id>regcomp()</id></def>
</definitions>
The flags defaults to not set. You can set one, two or all three, as separate
trailing parameters.
<p/>
Be careful with the C/C++ rules for escapes when a regular expression
requires \.
<p/>
Example:
<code>
  TEST(looks_like_ipaddr)
  {
    using crpcut::match;
    using crpcut::regex;

    const char *ipaddr = afunc();
    static const char pattern[] = "^([[:digit:]]{1,3}\\.){3}[[:digit:]]{1,3}$";
    ASSERT_PRED(match&lt;regex&gt;(pattern, regex::e), ipaddr);
  }
</code>
</section>
</chapter>
<chapter title="Comparing floating point values">
Comparing floating point values for equality is tricky. Due to rounding errors,
you do normally not want to check that a computed value is exactly equal to
an expected value, but rather that the computed value is close to the
expected, with some chosen precision.
<p/>
crpcut provides three ways of expressing that precision, with their
advantages and disadvantages.
<definitions>
<def notion="relative_diff(diff)(a,&#xA0;b)">Check that 2*|a-b|/|a+b|&lt;=diff.
                                        E.g. if diff=0.01, the values a and b
                                        must not differ by more than 1%. The
                                        main disadvantage of
                                        <id>relative_diff</id> is when the
                                        expected values are close to 0.</def>
<def notion="abs_diff(diff)(a,&#xA0;b)">Check that |a-b|&lt;=diff. This works
                                       well for numbers near 0, but for large
                                       numbers it quickly becomes
                                       uninteresting.</def>
<def notion="ulps_diff(diff,&#xA0;inf)(a,&#xA0;b)">Check that the number of
                                                   possible floating point
                                                   values between <id>a</id> and
                                                   <id>b</id> is not greater
                                                   than <id>diff</id>.
                                                   <id>inf</id> can be one of
                                                   <id>include_inf</id> or
                                                   <id>exclude_inf</id> and
                                                   controls whether infinity
                                                   is a valid number (one
                                                   representation away from max)
                                                   or not. It defaults to
                                                   <id>exclude_inf</id>. See
<link url="http://www.cygnus-software.com">Cygnus</link> information on
<link url="http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm">comparing floating point numbers</link>, and also David Goldberg's <link
url="http://docs.sun.com/source/806-3568/ncg_goldberg.html">What Every Computer Scientists Should Know About Floating-Point Arithmetic</link>.
</def>
</definitions>
Floating point comparisons are made using <id>ASSERT_PRED</id> with the
<id>match</id> function template like this:
<code>
  ASSERT_PRED(crpcut::match&lt;crpcut::abs_diff&gt;(0.0001), a, b);
</code>

The two values must all have exactly the same floating point type. For
<id>relative_diff</id> and <id>abs_diff</id> the precision must also be
of the same type as the compared values. For <id>ulps_diff</id> the
precision is an unsigned integer. <id>ulps_diff</id> is not available for
<id>long double</id>.
<p/>
It is worth pointing out that arithmetics with <id>long double</id> might
work poorly when run under <link url="http://www.valgrind.org">valgrind</link>,
since it (at least in version 3.4.1 and older) never makes floating point
calculations with greater precision than
64 bits (<id>double</id>.)
</chapter>

<chapter title="The main program">
The normal <id>main()</id> is exactly the below:
<code>
  int main(int argc, char *argv[])
  {
    return crpcut::test_case_factory::run_test(argc, argv);
  }
</code>
<id>crpcut::test_case_factory::run_test()</id> expects parameters as a set of
flags followed by a set of test case or test suite names. The flags are:
<definitions notion="flag" meaning="meaning">
<def notion="-l">List, on stdout, all test cases matching the test case or test
                 suite names, then exit with code 0.
                 </def>
<def notion="-d&#xA0;name">Set working dir for test to named directory. The
                           directory must exist prior to run, and should
                           preferably be empty. By default a directory is
                           created under /tmp/crpcut??????</def>
<def notion="-n">Ignore dependencies when running tests.</def>
<def notion="-v">Include the result of successful tests, in addition to that
                 of the failed ones, in the test report.</def>
<def notion="-c&#xA0;num">Control the number of parallel spawned test
                          case processes. The default is 1. -c cannot be
                          combined with -s (below.)</def>
<def notion="-s">Single-shot - run a single test case, and run it in the main
                 process. Useful for running a test case in a debugger. -s
                 implies -n (above) and cannot be combined with -c (also
                 above.)</def>
<def notion="-o&#xA0;file">Direct xml output to named file. Brief result
                           will be displayed on stdout.</def>
<def notion="-p&#xA0;name=value">Create a named command line parameter to be
                                 accessed from test cases.</def>
<def notion="-q">Don't display the -o brief</def>
<def notion="-x">Print XML-output on stdout or non-XML to named file
                 (-o above)</def>
</definitions>
Note that <id>-s</id> provides an environment that is markedly different
from a normal run in a child process. Most notably no post-mortem checks are
made (files left behind, processing of termination reason.) Also INFO and
FAIL streamers (above) just print to stdout/stderr. Exit code from the run
will be 0 on success, and whatever the process exits with on failure
(typically SIGABRT from the ASSERT_* macros.) Tests that die,
will also terminate the program, even if death is expected.
<p/>
To run the tests in test suite named &quot;asserts&quot;, 8 test cases in
parallel, ignore all dependencies, and print also successful tests, start the
test program using <id>-n&#xA0;-v&#xA;-c&#xA;8 asserts</id>.
<p/>
The exact prototype for <id>run_test</id> is:
<code>
  namespace crpcut {
    class test_case_factory
    {
    public:
      static int run_test(int argc, const char *argv[], std::ostream &amp; = std::cerr);
    };
  }
</code>
The return value is the number of failed tests, or -1 if anything was printed
on the stream. The output stream is where to print information if the
parameters in the call don&apos;t make sense.
<p/>
The result from a test run is printed on stdout, or the file named with
the <id>-o</id> flag. By default, the result on stdout is a human readable
format, while output to a named file (the <id>-o</id> flag) is formatted using
the XML Schema provided in <id>crpcut.xsd</id>. The <id>-x</id> flag inverts
the output formats so output on stdout becomes XML-formatted and named file
output becomes human readable.
<p/>
The test program must be linked with <id>libcrpcut.so</id>. If you use
<link url="http://code.google.com/p/googlemock">google-mock</link>, extra care
must be taken with the linking. You must link with both <id>libcrpcut.so</id>
and <id>libcrpcut_gmock.so</id> from crpcut, before <id>libgmock.so</id> and
<id>libgtest.so</id> from the
<link url="http://code.google.com/p/googlemock">google-mock</link> installation.
Failing to follow this link order may produce a program that can run, but
will behave erratically.
</chapter>

<chapter title="Debugging">
Debugging a test case is easy. Load the test program into your favourite
debugger. Set a break point on <id>testcasename::test</id>. Run with
<id>-s&#xA0;testcasename</id>. Example:
<code>
&gt;$ gdb --args ./test/testprog -s asserts::should_succeed_assert_no_throw
GNU gdb 6.8
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-pc-linux-gnu"...
(gdb) break asserts::should_succeed_assert_no_throw::test
Breakpoint 1 at 0x487ce4: file /home/bjorn/devel/crpcut/test-src/asserts_and_depends.cpp, line 80.
(gdb) run
Starting program: /var/tmp/build/test/testprog -s -n asserts::should_succeed_assert_no_throw
[Thread debugging using libthread_db enabled]
[New Thread 0x7f5605d43700 (LWP 17769)]
[Switching to Thread 0x7f5605d43700 (LWP 17769)]

Breakpoint 1, asserts::should_succeed_assert_no_throw::test (this=0x7fff0dd76340)
    at /home/bjorn/devel/crpcut/test-src/asserts_and_depends.cpp:80
80          ASSERT_NO_THROW(i=1);
(gdb) quit
</code>
From there, you can single step the test case.
</chapter>
<chapter title="Advanced techniques">
<section title="File system access">
Since all test cases run in their own working directory, the path to the
working directory when starting the test suite is lost. If you need that
path, for example to populate test vectors from a file, you can get the
path name through the static member function:
<code>
  const char *crpcut::test_case_factory::get_start_dir();
</code>
</section>
<section title="Named command line parameters">
Named command line parameters, added to the test run with the <id>-p</id>
switch, can be accessed from within the test cases using:
<code>
  class test_case_factory
  {
  public:
    static const char *get_parameter(const char *name);

    template &lt;typename T&gt;
    static void get_parameter(const char *name, T&amp; t);

    template &lt;typename T&gt;
    static T get_parameter(const char *name);
  };
</code>
The first returns the raw value of the parameter, or 0 if none was found.
The other two fails the test case if the value is not found, or cannot be
interpreted as the desired type by means of input streaming.
</section>
<section title="Predicates">
A predicate is anything that looks like a function and returns a type that can
be evaluated as a boolean expression. A predicate can be a free function
pointer, a static member function, or an object with <id>operator()</id>.
<p/>
The <link url="http://www.boost.org">BOOST</link> C++ library plays especially
well with predicates, particularly <id>boost::bind</id> and
<id>boost::lambda</id>. Take for example:
<code>
  const char *p = afunc();
  ASSERT_PRED(boost::bind(std::strcmp, _1, _2) == 0, "expected", p);
</code>
You can also make a thin wrapper using your own templates:
<code>
  template &lt;typename R, typename P1, typename P2&gt;
  struct binder&lt;R (*)(P1, P2)&gt;
  {
    typedef R (*proto)(P1, P2);
    typedef decltype boost::bind(proto(0), _1, _2) type;
    static type bind(proto f) { return boost::bind(f, _1, _2); }
  };

  template &lt;typename F&gt;
  typename binder&lt;F&gt;::type return_of(F f)
  {
    return binder&lt;F&gt;::bind(f);
  }
</code>
The above thin wrapper can be used as:
<code>
  const char *p = afunc();
  ASSERT_PRED(return_of(std::strcmp) == 0, "expected", p);
</code>
Should the above fail, the violation message will be:
<code>
  ASSERT_PRED(return_of(std::strcmp) == 0, "expected", p)
    param1 = expected
    param2 = otherval
</code>
<p/>
If a predicate has an output stream operator, it will be used to add
further information to violation messages.
An alternative to the wrapper above may be:
<code>
  class equal
  {
  public:
    equal(const char *ref) : r(ref) {}
    bool operator()(const char *v) const { return strcasecmp(v, r) == 0; }
    friend std::ostream&amp; operator&lt;&lt;(std::ostream &amp;os, const equal &amp;e)
    {
      return os &lt;&lt; "case insensitive string equal to \"" &lt;&lt; e.r &lt;&lt; "\"";
    }
  private:
    const char *r;
  };
</code>
Its use can be:
<code>
  const char *p = afunc();
  ASSERT_PRED(equal("expected"), p);
</code>
A violation message would be:
<code>
  ASSERT_PRED(equal("expected", p))
    equal("expected") : case insensitive string equal to "expected"
    param1 = otherval
</code>
<p/>
</section>
<section title="Writing your own matchers">
  A matcher is a value testing class that is instantiated via the
  <id>match&lt;&gt;</id> function template. A matcher instance can be
  used as a predicate (see above) or tested directly as a boolean value.
  <p/>
  By default <id>match&lt;T&gt;(...)</id> returns an instance of T(...).
  <id>match&lt;&gt;()</id> is overridden for 0 up to 9 templated parameter
  values.
  <p/>
  To be used as a predicate, the matcher must implement
  <id>bool&#xA0;operator()</id> with a suitable number of parameters.
  <p/>
  Beware that since the <id>match&lt;T&gt;()</id> function template will
  return a T by value, the matcher <id>T</id> must be copy constructible
  (or more accurately, it must be move constructible.)
  <p/>
  It is advisable to define an output streaming operator for a matcher.
  The output stream operator will only be called when the predicate
  has failed, and here extra information can be added that makes it
  easier to understand the reason for the failure.
  <p/>
  Should instantiating <id>T</id> directly not be suitable, the return value
  from the instantiation of <id>match&lt;T&gt;(...)</id> can be controlled
  by specializing the <id>crpcut::match_traits&lt;T,...&gt;</id>
  template (where ... is the parameters to the <id>match&lt;T&gt;(...)</id>
  call. This way the type returned can be controlled also by the types of the
  parameters to <id>match&lt;&gt;()</id>.
  <p/>
  A complete, if somewhat contrived example, testing that two pointers
  point to the same value.
  <code>
  class ptr_deref_eq
  {
  public:
    template &lt;typename T&gt;
    class type
    {
    public:
      type(T* refp) : rp(refp) {}
      type(const type&lt;T&gt;&amp; t) : rp(t.rp), cp(t.cp) {}
      bool operator()(T* compp)
      {
        cp = compp; // store values for use by output stream operator
        return *rp == *cp;
      }
      friend std::ostream&amp; operator&lt;&lt;(std::ostream &amp;os, const type&lt;T&gt;&amp; t)
      {
        os &lt;&lt; "reference ptr=" &lt;&lt; t.rp &lt;&lt; " pointing to:" &lt;&lt; *t.rp
           &lt;&lt; "\ncompared ptr=" &lt;&lt; t.cp &lt;&lt; " pointing to: " &lt;&lt; *t.cp;
        return os;
      }
    private:
      T* rp;
      T* cp;
    };
  };

  namespace crpcut {
    template &lt;typename T&gt;
    struct match_traits&lt;ptr_deref_eq, T*&gt;
    {
      typedef typename ptr_deref_eq::template type&lt;T&gt; type;
    };
  } // namespace crpcut
  </code>
  It's use can be:
  <code>
    int *p1 = afunc();
    int n = 3;
    ASSERT_PRED(crpcut::match&lt;ptr_deref_eq&gt;(&amp;n), p1);
  </code>
</section>
<section title="Wrapping library functions">
crpcut accesses all functions it uses from <id>libc</id> and <id>librt</id>
directly from the lib by means of <id>dlsym()</id>. This means that you can
define your own versions of those functions in global namespace, if you need it
for your testing. Be aware, however, that the C++ standard library may
use some of these functions, and so may
<link url="http://code.google.com/p/googlemock">google-mock</link>. So,
while creating your own
<id>int&#xA0;write(int&#xA0;fd,&#xA0;const&#xA0;void&#xA0;*addr,&#xA0;size_t&#xA0;bytes)</id>
will not harm crpcut, it will probably cause <id>std::ofstream</id> to
misbehave.
<p/>
If you need to create wrappers of your own, you can easily do that
through the macros and traits templates available in <id>crpcut.hpp</id>.
<code>
  CRPCUT_WRAP_FUNC(libname, funcname, rettype, prototype_params, call_params)
</code>
<definitions notion="macro param" meaning="meaning">
<def notion="libname">name of the library in which the function resides.
                      Predefined names are <id>libc</id> and
                      <id>librt</id></def>
<def notion="funcname">The name of the function, without quotes.</def>
<def notion="rettype">The return type of the function.</def>
<def notion="prototype_params">Types and names for all parameters to the
                               function, enclosed in parenthesis.</def>
<def notion="call_params">The names from <id>prototype_params</id> without
                          type information, comma separated and enclosed in
                          parenthesis.</def>
</definitions>
For functions without return value, there's also a <id>CRPCUT_WRAP_V_FUNC()</id>
macro. It has the exact same parameter list (including <id>rettype</id>, which
typically is <id>void</id>, but may optionally include some attribute, like
<id>__attribute__((noreturn))</id>.) The original function will be accessible
through the namespace from which <id>CRPCUT_WRAP_FUNC()</id> was instantiated.
<p/>
This is easiest to explain through an example. Say you want to intercept
all calls to <id>fopen()</id>. You want it to do what it normally does,
but you want to validate its parameters. A way of doing that is as follows:
<code>
  extern "C" {
    #include &lt;stdio.h&gt;
  }
  #include &lt;crpcut.hpp&gt;
  namespace mywraps {
    CRPCUT_WRAP_FUNC(libc, fopen, FILE*, (const char *p, const char *m), (p, m))
  }
  FILE* fopen(const char *p, const char *m)
  {
    ASSERT_TRUE(p);
    ASSERT_TRUE(m);
    return mywraps::fopen(p, m);
  }
</code>
By default the libraries <id>libc</id> and <id>librt</id> are known by
crpcut. If you want to access functions in other libraries, you add your
own constants under the namespace <id>crpcut::libs</id>. These must be
positive integers. You also provide your own specialization of the
traits template
<id>const&#xA0;char&#xA0;*crpcut::libwrapper::traits&lt;int&gt;::name[]</id>.
The last element in the <id>name</id> array must be 0. crpcut tries the
library names in the order they appear in the <id>name</id> array, until it
succeeds. If no library can be found, crpcut will segfault.
<p/>
A complete example for the function <id>asin()</id> in the <id>libm</id>
library:
<code>
  extern "C" {
    #include &lt;math.h&gt;
  }
  #include &lt;crpcut.hpp&gt;

  namespace crpcut {
    namespace libs {
      static const int libm = 1;
    }
    namespace libwrapper {
      template &lt;&gt;
      const char *traits&lt;libs::libm&gt;::name[] = {
        "libm.so",
        "libm.so.6",
        0
      };
    }
  }
  namespace mymath {
    CRPCUT_WRAP_FUNC(libm, asin, double, (double d), (d))
  }
</code>
Now the function <id>mymath::asin()</id> will call the original
function in <id>libm</id>, and you can define your own <id>asin()</id> in
global namespace for testing purposes.
<code>
  extern "C"
  {
    double asin(double d)
    {
      ASSERT_GE(d, -1.0);
      ASSERT_LE(d, 1.0);
      return mymath::asin(d);
    }
  }
</code>
</section>
</chapter>

<chapter title="Further development">
The todo list, without any regard to importance or desired implementation
order is:
<list>
<li>Set regexp match rules for stdout and stderr (probably won't happen before 1.0)</li>
<li>OS/X compatibility would be nice</li>
</list>
</chapter>
</doc>

